---
title: 秒杀系统设计
date: 2020-03-08 14:31:00
update: 2020-03-08 14:31:00
categories: Redis
tags: [redis]
---

<div style="text-align: center"><iframe height="60" width="260" src="https://www.ximalaya.com/thirdparty/player/sound/player.html?id=49127030&type=red" frameborder=0 allowfullscreen></iframe></div>

<img style="width: 80%;height:80%" src="https://volc1612.gitee.io/blog/images/秒杀系统设计/安徽宏村.jfif"/>

<!-- more -->

### 布隆过滤器（BloomFilter）


- 黑客流量攻击：故意访问不存在的数据，导致程序不断访问DB数据库的数据
- 黑客安全阻截：当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉
- 思考：如果让你实现这个功能你会怎么做？   key：10000 10001  10002 10003  大集合，key是否在集合里面
- 温故而知新：分析java常用数据结构复习  set  map key,value  list 有序get[0]、get[1]； 
-   list.contain (key)遍历数据，进行equals()比较，性能小
-  set.contain(key) hashcode比较，性能较高，64位  1G
-   map.get(key) hashcode比较，性能还行
- 概念：

  - **布隆过滤器**（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的[二进制](https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6)向量和一系列随机[映射函数](https://zh.wikipedia.org/wiki/%E6%98%A0%E5%B0%84)。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。
- 优点:

  - 相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数（{\displaystyle O(k)}![O(k)](https://wikimedia.org/api/rest_v1/media/math/render/svg/f5ec39041121b14e8c2b1a986c9b04547b223e3c)）。另外，散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势
- 缺点
  - 但是布隆过滤器的缺点和优点一样明显。误算率是其中之一。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣

- 布隆过滤器的其他使用场景

    1. 网页爬虫对URL的去重，避免爬取相同的URL地址；
    2. 反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）；
    3. 缓存击穿，将已存在的缓存放到布隆中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。

* 布隆过滤器实现原理图解

    ![布隆过滤器实现原理](https://volc1612.gitee.io/blog/images/秒杀系统设计/布隆过滤器实现原理.jpg)
    ![带你了解布隆过滤器.jpg](https://volc1612.gitee.io/blog/images/秒杀系统设计/带你了解布隆过滤器.jpg)

**布隆过滤器只能判断出有可能存在和一定不存在，不能判断出一定存在**

### 布隆过滤器的基础使用

* 初始化数据到布隆过滤器中
    ```java
    import com.google.common.hash.BloomFilter;
    import com.google.common.hash.Funnels;
    import com.xdclass.mobile.xdclassmobileredis.domain.SysUser;
    import com.xdclass.mobile.xdclassmobileredis.domain.SysUserExample;
    import com.xdclass.mobile.xdclassmobileredis.mapper.SysUserMapper;
    import org.springframework.stereotype.Service;
    import org.springframework.util.CollectionUtils;

    import javax.annotation.PostConstruct;
    import javax.annotation.Resource;
    import java.util.List;

    @Service
    public class BloomFilterService {

        @Resource
        private SysUserMapper sysUserMapper;

        private BloomFilter<Integer> bf;

        /***
        * PostConstruct 程序启动时候加载此方法
        */
        @PostConstruct
        public void initBloomFilter() {
            SysUserExample sysUserExample = new SysUserExample();
            List<SysUser> sysUserList = sysUserMapper.selectByExample(sysUserExample);
            if (CollectionUtils.isEmpty(sysUserList)) {
                return;
            }
            //创建布隆过滤器(默认3%误差)
            bf = BloomFilter.create(Funnels.integerFunnel(), sysUserList.size());
            for (SysUser sysUser : sysUserList) {
                bf.put(sysUser.getId());
            }
        }

        /***
        * 判断id可能存在于布隆过滤器里面
        * @param id
        * @return
        */
        public boolean userIdExists(int id) {
            return bf.mightContain(id);
        }
    }
    ```

* 判断数据是否可能存在

    ```java
    private BloomFilter<Integer> bf;
    return bf.mightContain(id)
    ```

### google的布隆过滤器和redis的布隆过滤器

- google布隆过滤器的缺陷与思考

  - 基于内存布隆过滤器有什么特点

  - 内存级别产物
  - 重启即失效
  - 本地内存无法用在分布式场景
  - 不支持大数据量存储

- 需求分析步骤

  - 互联网功能需求分析
    - 这是一个抽奖程序，只针对会员用户有效
  - 抽离出功能所有api
  - 制定存储方案
  - 性能优化方案分析

- Redis布隆过滤器

  * 可扩展性Bloom过滤器
    * 一旦Bloom过滤器达到容量，就会在其上创建一个新的过滤器
  * 不存在重启即失效或者定时任务维护的成本
    * 基于goole实现的布隆过滤器需要启动之后初始化布隆过滤器
  * 缺点：
    * 需要网络IO,性能比基于内存的过滤器低

- 选择:

     优先基于数据量进行考虑

### 安装redis布隆过滤器

#### 回顾哨兵模式的搭建-启动6379(主)和6380(从)节点

* 目录结构

```sh
[root@localhost redis_sentinel]# pwd
/usr/local/src/redis4/redis-4.0.6/redis_sentinel
[root@localhost redis_sentinel]# ll
total 5640
drwxr-xr-x. 2 root root    4096 Mar  8 20:08 6379
drwxr-xr-x. 2 root root    4096 Mar  8 20:08 6380
-rw-r--r--. 1 root root       0 Mar  8 18:46 appendonly.aof
-rw-r--r--. 1 root root     114 Mar  8 18:46 nodes.conf
-rwxr-xr-x. 1 root root 5753128 Mar  8 18:46 redis-server
-rw-r--r--. 1 root root    7701 Mar  8 20:09 sentinel.conf
```

redis_sentinel(哨兵模式)目录下主要有redis-server和sentinel.conf，以及节点配置文件

```sh
[root@localhost 6379]# ll
total 72
-rw-r--r--. 1 root root   134 Mar  8 20:10 appendonly.aof
-rw-r--r--. 1 root root   192 Mar  8 20:08 dump.rdb
-rw-r--r--. 1 root root   951 Mar  8 18:46 nodes.conf
-rw-r--r--. 1 root root 57754 Mar  8 20:07 redis.conf
```

* 主从节点配置文件

6379主

```sh
# 修改成对应调的端口号
port 6379
# 注释掉 bind 配置
# bind 127.0.0.1
daemonize yes
cluster-enabled no
cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly yes
protected-mode no
```

6380从

```sh
# 修改成对应调的端口号
port 6380
# 注释掉 bind 配置
# bind 127.0.0.1
daemonize yes
cluster-enabled no
cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly yes
protected-mode no
# 配置主节点是6379
slaveof 127.0.0.1 6379
```

哨兵服务配置文件

```sh
sentinel monitor mymaster 192.168.25.11 6379 1   
sentinel down-after-milliseconds mymaster 10000
sentinel failover-timeout mymaster 60000
sentinel parallel-syncs mymaster 1
protected-mode no
```

`192.168.25.11`服务外网IP

* 启动哨兵服务

```sh
[root@localhost redis-4.0.6]# ./src/redis-sentinel redis_sentinel/sentinel.conf
```

#### 编译安装布隆过滤器模块

```sh
[root@localhost redis4]# git clone git://github.com/RedisLabsModules/rebloom
Cloning into 'rebloom'...
remote: Enumerating objects: 28, done.
remote: Counting objects: 100% (28/28), done.
remote: Compressing objects: 100% (28/28), done.
remote: Total 1834 (delta 10), reused 0 (delta 0), pack-reused 1806
Receiving objects: 100% (1834/1834), 521.58 KiB | 6.00 KiB/s, done.
Resolving deltas: 100% (1178/1178), done.
[root@localhost redis4]# ll
total 1692
drwxr-xr-x. 9 root root    4096 Mar  8 20:27 rebloom
drwxrwxr-x. 9 root root    4096 Mar  8 18:47 redis-4.0.6
-rw-r--r--. 1 volc volc 1723533 Dec  5  2017 redis-4.0.6.tar.gz
[root@localhost redis4]# cd rebloom
[root@localhost rebloom]# make
[root@localhost rebloom]# ll
total 376
-rw-r--r--. 1 root root    211 Mar  8 20:27 changelog
drwxr-xr-x. 2 root root   4096 Mar  8 20:28 contrib
-rw-r--r--. 1 root root    405 Mar  8 20:27 Dockerfile
drwxr-xr-x. 3 root root   4096 Mar  8 20:27 docs
-rw-r--r--. 1 root root   5794 Mar  8 20:27 LICENSE
-rw-r--r--. 1 root root   2634 Mar  8 20:27 Makefile
-rw-r--r--. 1 root root    946 Mar  8 20:27 mkdocs.yml
-rw-r--r--. 1 root root    511 Mar  8 20:27 ramp.yml
-rw-r--r--. 1 root root   3289 Mar  8 20:27 README.md
-rwxr-xr-x. 1 root root 331720 Mar  8 20:28 redisbloom.so
drwxr-xr-x. 2 root root   4096 Mar  8 20:28 rmutil
drwxr-xr-x. 2 root root   4096 Mar  8 20:28 src
drwxr-xr-x. 2 root root   4096 Mar  8 20:27 tests
```

* 关闭节点并配置加载布隆过滤器模块

6379和6380的redis.conf文件配置中添加配置

```sh
loadmodule /usr/local/src/redis4/rebloom/redisbloom.so
```

* 启动redis节点

#### 验证redis布隆过滤器

```sh
[root@localhost src]# ./redis-cli -p 6379
127.0.0.1:6379> BF.ADD mybloom redis1
(integer) 1
127.0.0.1:6379> BF.ADD mybloom redis2
(integer) 1
127.0.0.1:6379> 
127.0.0.1:6379> BF.EXISTS mybloom redis1
(integer) 1
```

命令：

```sh
BF.ADD bloomname key
BF.EXISTS bloomname key
```

### redis布隆过滤器和springboot整合

redis布隆过滤器提供了支持单机和集群api，并没有提供支持哨兵服务，这里需要支持哨兵模式对布隆过滤器进行读写
方案： 使用lua脚本使用布隆过滤器

RedisService.java提供添加数据到布隆过滤器和查询数据的方法

```java
/**
    * @Description: redis布隆过滤器提供了支持单机和集群api，并没有提供支持哨兵服务
    * 这里需要支持哨兵模式的读写，方案： 使用lua脚本使用布隆过滤器
    * 封装redis布隆过滤器支持sentinel-添加数据
    * @Param: [value]
    * @return: java.lang.Boolean
    * @Date: 2020/3/8
    */
public Boolean bloomFilterAdd(int value) {
    DefaultRedisScript<Boolean> bloomAdd = new DefaultRedisScript<>();
    bloomAdd.setScriptSource(new ResourceScriptSource(new ClassPathResource("bloomFilterAdd.lua")));
    bloomAdd.setResultType(Boolean.class);
    List<Object> keyList = new ArrayList<>();
    keyList.add("isVipBloom");
    keyList.add(value + "");
    Boolean result = (Boolean) redisTemplate.execute(bloomAdd, keyList);
    return result;
}


/**
    * @Description: 封装redis布隆过滤器支持sentinel-查询布隆过滤器中是否存在
    * @Param: [value]
    * @return: java.lang.Boolean
    * @Date: 2020/3/8
    */
public Boolean bloomFilterExists(int value) {
    DefaultRedisScript<Boolean> bloomExists = new DefaultRedisScript<>();
    bloomExists.setScriptSource(new ResourceScriptSource(new ClassPathResource("bloomFilterExist.lua")));
    bloomExists.setResultType(Boolean.class);
    List<Object> keyList = new ArrayList<>();
    keyList.add("isVipBloom");
    keyList.add(value + "");
    Boolean result = (Boolean) redisTemplate.execute(bloomExists, keyList);
    return result;
}
```

bloomFilterAdd.lua

```lua
local bloomName = KEYS[1]
local value = KEYS[2]

-- bloomFilter
local result_1 = redis.call('BF.ADD', bloomName, value)
return result_1
```

bloomFilterExist.lua

```lua
local bloomName = KEYS[1]
local value = KEYS[2]

-- bloomFilter
local result_1 = redis.call('BF.EXISTS', bloomName, value)
return result_1
```

* 接口验证

```java
import com.xdclass.mobile.xdclassmobileredis.RedisService;
import com.xdclass.mobile.xdclassmobileredis.service.BloomFilterService;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;

@RestController
public class BloomFilterController {

    @Resource
    private BloomFilterService bloomFilterService;

    @Resource
    private RedisService redisService;


    @RequestMapping("/bloom/idExists")
    public boolean ifExists(int id) {
        return bloomFilterService.userIdExists(id);
    }


    @RequestMapping("/bloom/redisIdExists")
    public boolean redisidExists(int id) {
        return redisService.bloomFilterExists(id);
    }

    @RequestMapping("/bloom/redisIdAdd")
    public boolean redisidAdd(int id) {
        return redisService.bloomFilterAdd(id);
    }
}
```

