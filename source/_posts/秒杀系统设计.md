---
title: 秒杀系统设计
date: 2020-03-08 14:31:00
update: 2020-03-08 14:31:00
categories: Redis
tags: [redis]
---

<div style="text-align: center"><iframe height="60" width="260" src="https://www.ximalaya.com/thirdparty/player/sound/player.html?id=49127030&type=red" frameborder=0 allowfullscreen></iframe></div>

<img style="width: 80%;height:80%" src="https://volc1612.gitee.io/blog/images/微信红包实现原理/桂林.jpg" />

<!-- more -->

### 布隆过滤器（BloomFilter）


- 黑客流量攻击：故意访问不存在的数据，导致程序不断访问DB数据库的数据
- 黑客安全阻截：当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉
- 思考：如果让你实现这个功能你会怎么做？   key：10000 10001  10002 10003  大集合，key是否在集合里面
- 温故而知新：分析java常用数据结构复习  set  map key,value  list 有序get[0]、get[1]； 
-   list.contain (key)遍历数据，进行equals()比较，性能小
-  set.contain(key) hashcode比较，性能较高，64位  1G
-   map.get(key) hashcode比较，性能还行
- 概念：

  - **布隆过滤器**（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的[二进制](https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6)向量和一系列随机[映射函数](https://zh.wikipedia.org/wiki/%E6%98%A0%E5%B0%84)。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。
- 优点:

  - 相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数（{\displaystyle O(k)}![O(k)](https://wikimedia.org/api/rest_v1/media/math/render/svg/f5ec39041121b14e8c2b1a986c9b04547b223e3c)）。另外，散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势
- 缺点
  - 但是布隆过滤器的缺点和优点一样明显。误算率是其中之一。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣

- 布隆过滤器的其他使用场景

    1. 网页爬虫对URL的去重，避免爬取相同的URL地址；
    2. 反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）；
    3. 缓存击穿，将已存在的缓存放到布隆中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。

* 布隆过滤器实现原理图解

    ![布隆过滤器实现原理](https://volc1612.gitee.io/blog/images/秒杀系统设计/布隆过滤器实现原理.jpg)
    ![带你了解布隆过滤器.jpg](https://volc1612.gitee.io/blog/images/秒杀系统设计/带你了解布隆过滤器.jpg)

**布隆过滤器只能判断出有可能存在和一定不存在，不能判断出一定存在**

### 布隆过滤器的基础使用

* 初始化数据到布隆过滤器中
    ```java
    import com.google.common.hash.BloomFilter;
    import com.google.common.hash.Funnels;
    import com.xdclass.mobile.xdclassmobileredis.domain.SysUser;
    import com.xdclass.mobile.xdclassmobileredis.domain.SysUserExample;
    import com.xdclass.mobile.xdclassmobileredis.mapper.SysUserMapper;
    import org.springframework.stereotype.Service;
    import org.springframework.util.CollectionUtils;

    import javax.annotation.PostConstruct;
    import javax.annotation.Resource;
    import java.util.List;

    @Service
    public class BloomFilterService {

        @Resource
        private SysUserMapper sysUserMapper;

        private BloomFilter<Integer> bf;

        /***
        * PostConstruct 程序启动时候加载此方法
        */
        @PostConstruct
        public void initBloomFilter() {
            SysUserExample sysUserExample = new SysUserExample();
            List<SysUser> sysUserList = sysUserMapper.selectByExample(sysUserExample);
            if (CollectionUtils.isEmpty(sysUserList)) {
                return;
            }
            //创建布隆过滤器(默认3%误差)
            bf = BloomFilter.create(Funnels.integerFunnel(), sysUserList.size());
            for (SysUser sysUser : sysUserList) {
                bf.put(sysUser.getId());
            }
        }

        /***
        * 判断id可能存在于布隆过滤器里面
        * @param id
        * @return
        */
        public boolean userIdExists(int id) {
            return bf.mightContain(id);
        }
    }
    ```

* 判断数据是否可能存在

    ```java
    private BloomFilter<Integer> bf;
    return bf.mightContain(id)
    ```

### google的布隆过滤器和redis的布隆过滤器

- google布隆过滤器的缺陷与思考

  - 基于内存布隆过滤器有什么特点

  - 内存级别产物
  - 重启即失效
  - 本地内存无法用在分布式场景
  - 不支持大数据量存储

- 需求分析步骤

  - 互联网功能需求分析
    - 这是一个抽奖程序，只针对会员用户有效
  - 抽离出功能所有api
  - 制定存储方案
  - 性能优化方案分析

- Redis布隆过滤器

  * 可扩展性Bloom过滤器
    * 一旦Bloom过滤器达到容量，就会在其上创建一个新的过滤器
  * 不存在重启即失效或者定时任务维护的成本
    * 基于goole实现的布隆过滤器需要启动之后初始化布隆过滤器
  * 缺点：
    * 需要网络IO,性能比基于内存的过滤器低

- 选择:

     优先基于数据量进行考虑