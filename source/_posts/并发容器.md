---
title: 并发容器
date: 2019-05-05 12:35:45
update: 2019-05-05 12:35:45
categories: 并发编程
tags: [并发编程]
---

### `HashMap`和`HashTable`

Hashmap多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。
HashTable使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。
putIfAbsent() ：没有这个值则放入map，有这个值则返回key本来对应的值。

<!-- more -->

### 并发容器

> Hash

散列，哈希：把任意长度的输入通过一种算法（散列），变换成为固定长度的输出，这个输出值就是散列值。属于压缩映射，容易产生哈希冲突。`Hash`算法有直接取余法等。
产生哈希冲突时解决办法：开放寻址；2、再散列；3、链地址法（相同hash值的元素用链表串起来）。
`ConcurrentHashMap`在发生hash冲突时采用了链地址法。
`md4`,`md5`,`sha-hash`算法也属于`hash`算法，又称摘要算法。

> 位运算

```java
import java.io.UnsupportedEncodingException;

/**
 * 类说明：演示位运算
 */
public class IntToBinary {

    public static void main(String[] args) throws UnsupportedEncodingException {

        int data = 4;
        System.out.println("the 4 is " + Integer.toBinaryString(data));

        //位与  &(1&1=1 1&0=0 0&0=0)
        System.out.println("the 4 is " + Integer.toBinaryString(4));
        System.out.println("the 6 is " + Integer.toBinaryString(6));
        System.out.println("the 4&6 is " + Integer.toBinaryString(4 & 6));
        //位或 | (1|1=1 1|0=1 0|0=0)
        System.out.println("the 4|6 is " + Integer.toBinaryString(4 | 6));
        //位非~（~1=0  ~0=1）
        System.out.println("the ~4 is " + Integer.toBinaryString(~4));
        //位异或 ^ (1^1=0 1^0=1 0^0=0)
        System.out.println("the 4^6 is " + Integer.toBinaryString(4 ^ 6));

        // <<有符号左移 >>有符号的右移  >>>无符号右移

        //取模的操作 a % (2^n) 等价于 a&(2^n-1)
        System.out.println("the 345 % 16 is " + (345 % 16) + " or " + (345 & (16 - 1)));

    }
}
```

使用位运算进行权限配置

```java
/**
 * 类说明：
 */
public class Permission {

    // 是否允许查询，二进制第1位，0表示否，1表示是  
    public static final int ALLOW_SELECT = 1 << 0; // 0001  = 1

    // 是否允许新增，二进制第2位，0表示否，1表示是  
    public static final int ALLOW_INSERT = 1 << 1; // 0010  = 2

    // 是否允许修改，二进制第3位，0表示否，1表示是  
    public static final int ALLOW_UPDATE = 1 << 2; // 0100  =4

    // 是否允许删除，二进制第4位，0表示否，1表示是  
    public static final int ALLOW_DELETE = 1 << 3; // 1000  = 8
    // 存储目前的权限状态  
    private int flag;

    //设置用户的权限
    public void setPer(int per) {
        flag = per;
    }

    //增加用户的权限（1个或者多个）
    public void enable(int per) {
        flag = flag | per;
    }

    //删除用户的权限（1个或者多个）
    public void disable(int per) {
        flag = flag & ~per;
    }

    //判断用户的权限
    public boolean isAllow(int per) {
        return ((flag & per) == per);
    }

    //判断用户没有的权限
    public boolean isNotAllow(int per) {
        return ((flag & per) == 0);
    }

    public static void main(String[] args) {
        int flag = 15;
        Permission permission = new Permission();
        permission.setPer(flag);
        permission.disable(ALLOW_DELETE | ALLOW_INSERT);
        System.out.println("select = " + permission.isAllow(ALLOW_SELECT));
        System.out.println("update = " + permission.isAllow(ALLOW_UPDATE));
        System.out.println("insert = " + permission.isAllow(ALLOW_INSERT));
        System.out.println("delete = " + permission.isAllow(ALLOW_DELETE));
    }
}
```

位运算使用场景：权限控制，物品的属性的保存

### 1.7JDK中`ConcurrentHashMap`中的数据结构

`ConcurrentHashMap`是由`Segment`数组结构和`HashEntry`数组结构组成。`Segment`实际继承自可重入锁（`ReentrantLock`），在`ConcurrentHashMap`里扮演锁的角色；`HashEntry`则用于存储键值对数据。一个`ConcurrentHashMap`里包含一个`Segment`数组，每个`Segment`里包含一个`HashEntry`数组，我们称之为`table`，每个`HashEntry`是一个链表结构的元素。

![并发容器_a](https://volc1612.gitee.io/blog/images/并发容器/并发容器_a.png)

> 面试常问

* ConcurrentHashMap实现原理是怎么样的或者问ConcurrentHashMap如何在保证高并发下线程安全的同时实现了性能提升？

答：ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了**锁分离**技术。它使用了多个锁来控制对hash表的不同部分进行的修改。内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，只要多个修改操作发生在不同的段上，它们就可以并发进行。

* 初始化做了什么事？

初始化有三个参数
`initialCapacity`：初始容量大小 ，默认16。
`loadFactor`: 扩容因子，默认0.75，当一个Segment存储的元素数量大于initialCapacity* loadFactor时，该Segment会进行一次扩容。
`concurrencyLevel`: 并发度，默认16。并发度可以理解为程序运行时能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数，实际上就是ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度。如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。

> 构造方法中部分代码解惑

* ![并发容器_b](https://volc1612.gitee.io/blog/images/并发容器/并发容器_b.png)







