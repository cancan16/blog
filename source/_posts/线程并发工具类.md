---
title: 线程并发工具类
date: 2019-04-22 23:35:45
update: 2019-04-22 23:35:45
categories: 并发编程
tags: [编发编程]
---

### Fork/Join

使用的标准范式

线程并发工具类_a.png

使用单线程统计数组总和

```java
import java.util.Random;

/**
 * 产生整形数组
 */
public class MakeArray {
    //数组长度
    public static final int ARRAY_LENGTH = 200000000;

    public static int[] makeArray() {

        //new一个随机数发生器
        Random r = new Random();
        int[] result = new int[ARRAY_LENGTH];
        for (int i = 0; i < ARRAY_LENGTH; i++) {
            //用随机数填充数组
            result[i] = r.nextInt(ARRAY_LENGTH * 3);
        }
        return result;
    }
}
```

```java
public class SumNormal {

    public static void main(String[] args) {
        int count = 0;
        int[] src = MakeArray.makeArray();

        long start = System.currentTimeMillis();
        for (int i = 0; i < src.length; i++) {
            //SleepTools.ms(1);
            count = count + src[i];
        }
        System.out.println("The count is " + count
                + " spend time:" + (System.currentTimeMillis() - start) + "ms");
    }
}
```

```
The count is -1090593142 spend time:110ms
```

使用Form/Join工具类统计数组总和

```java
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveTask;

public class SumArray {
    private static class SumTask extends RecursiveTask<Integer> {

        /***阈值*/
        private final static int THRESHOLD = MakeArray.ARRAY_LENGTH / 10;
        /***表示我们要实际统计的数组*/
        private int[] src;
        /***开始统计的下标*/
        private int fromIndex;
        /***统计到哪里结束的下标*/
        private int toIndex;

        public SumTask(int[] src, int fromIndex, int toIndex) {
            this.src = src;
            this.fromIndex = fromIndex;
            this.toIndex = toIndex;
        }

        /**
         * 递归拆分任务，合并结果
         *
         * @return
         */
        @Override
        protected Integer compute() {
            if (toIndex - fromIndex < THRESHOLD) {
                int count = 0;
                for (int i = fromIndex; i <= toIndex; i++) {
                    /***休眠1毫秒*/
                    //SleepTools.ms(1);
                    count = count + src[i];
                }
                return count;
            } else {
                //fromIndex....mid....toIndex
                //1...................70....100
                int mid = (fromIndex + toIndex) / 2;
                SumTask left = new SumTask(src, fromIndex, mid);
                SumTask right = new SumTask(src, mid + 1, toIndex);
                invokeAll(left, right);
                return left.join() + right.join();
            }
        }
    }


    public static void main(String[] args) {
        ForkJoinPool pool = new ForkJoinPool();
        int[] src = MakeArray.makeArray();
        SumTask innerFind = new SumTask(src, 0, src.length - 1);
        long start = System.currentTimeMillis();
        /***同步调用*/
        pool.invoke(innerFind);
        System.out.println("Task is Running.....");

        System.out.println("The count is " + innerFind.join()
                + " spend time:" + (System.currentTimeMillis() - start) + "ms");
    }
}
```

```
The count is 857590678 spend time:98ms
```

`Form/Join`工具`分而治之`思想并不能提高业务处理效率，还是要根据场景酌情考虑。

### Fork/Join的异步用法同时演示不要求返回值

* 遍历指定目录（含子目录）寻找指定类型文件

```java
import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveAction;

/**
 * 类说明：遍历指定目录（含子目录）找寻指定类型文件
 */
public class FindDirsFiles extends RecursiveAction {

    /***当前任务需要搜寻的目录*/
    private File path;

    public FindDirsFiles(File path) {
        this.path = path;
    }

    public static void main(String[] args) {
        try {
            // 用一个 ForkJoinPool 实例调度总任务
            ForkJoinPool pool = new ForkJoinPool();
            FindDirsFiles task = new FindDirsFiles(new File("D:/"));
            // 异步调用
            pool.execute(task);
            System.out.println("Task is Running......");
            Thread.sleep(1);
            int otherWork = 0;
            for (int i = 0; i < 100; i++) {
                otherWork = otherWork + i;
            }
            System.out.println("Main Thread done sth......,otherWork=" + otherWork);
            // 阻塞的方法
            task.join();
            System.out.println("Task end");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    protected void compute() {
        List<FindDirsFiles> subTasks = new ArrayList<>();
        File[] files = path.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    subTasks.add(new FindDirsFiles(file));
                } else {
                    // 遇到文件，检查
                    if (file.getAbsolutePath().endsWith("txt")) {
                        System.out.println("文件：" + file.getAbsolutePath());
                    }
                }
            }
            if (!subTasks.isEmpty()) {
                for (FindDirsFiles subTask : invokeAll(subTasks)) {
                    // 等待子任务执行完成
                    subTask.join();
                }
            }
        }
    }
}
```

### 常用的并发工具类

#### CountDownLatch

作用：是一组线程等待其他的线程完成工作以后在执行，加强版`join`。
`await`方法用来等待，`countDown`负责计数器的减一


模拟初始化线程执行完后，才执行业务线程的效果。

```java
import com.xiangxue.tools.SleepTools;
import java.util.concurrent.CountDownLatch;

/**
 * 模拟初始化线程执行完后，才执行业务线程的效果。
 * 类说明：演示CountDownLatch，有5个初始化的线程，6个扣除点，
 * 扣除完毕以后，主线程和业务线程才能继续自己的工作
 */
public class UseCountDownLatch {

    static CountDownLatch latch = new CountDownLatch(6);

    /***初始化线程(只有一步，有4个)*/
    private static class InitThread implements Runnable {

        @Override
        public void run() {
            System.out.println("Thread_" + Thread.currentThread().getId()
                    + " ready init work......");
            // 初始化线程完成工作了，countDown方法只扣减一次
            latch.countDown();
            for (int i = 0; i < 2; i++) {
                System.out.println("Thread_" + Thread.currentThread().getId()
                        + " ........continue do its work");
            }
        }
    }

    /**
     * 业务线程
     */
    private static class BusiThread implements Runnable {
        @Override
        public void run() {
            try {
                // 当上面主线程加上子线程没有扣除完才继续等待
                latch.await();

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            for (int i = 0; i < 3; i++) {
                System.out.println("BusiThread_" + Thread.currentThread().getId()
                        + " do business-----");
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        /***单独的初始化线程,初始化分为2步，需要扣减两次*/
        new Thread(new Runnable() {
            @Override
            public void run() {
                // 休眠1秒
                SleepTools.ms(1);
                System.out.println("Thread_" + Thread.currentThread().getId()
                        + " ready init work step 1st......");
                // 每完成一步初始化工作，扣减一次
                latch.countDown();
                System.out.println("begin step 2nd.......");
                SleepTools.ms(1);
                System.out.println("Thread_" + Thread.currentThread().getId()
                        + " ready init work step 2nd......");
                // 每完成一步初始化工作，扣减一次
                latch.countDown();
            }
        }).start();

        // 启动业务线程
        new Thread(new BusiThread()).start();
        // 运行初始化线程
        for (int i = 0; i <= 3; i++) {
            Thread thread = new Thread(new InitThread());
            thread.start();
        }
        // 主线程等待，当上面主线程加上子线程扣除完才继续执行latch.await()后面代码
        latch.await();
        Thread.sleep(1000);
        System.out.println("Main do ites work........");
    }
}
```

```
Thread_11 ready init work step 1st......
begin step 2nd.......
Thread_11 ready init work step 2nd......
Thread_13 ready init work......
Thread_13 ........continue do its work
Thread_13 ........continue do its work
Thread_15 ready init work......
Thread_15 ........continue do its work
Thread_15 ........continue do its work
Thread_16 ready init work......
Thread_16 ........continue do its work
Thread_16 ........continue do its work
Thread_14 ready init work......
Thread_14 ........continue do its work
Thread_14 ........continue do its work
BusiThread_12 do business-----
BusiThread_12 do business-----
BusiThread_12 do business-----
Main do ites work........
```




