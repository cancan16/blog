---
title: 线程池(2)
date: 2019-06-13 12:46:51
update: 2019-06-13 12:46:51
categories: THREAD
tags: [thread]
---

### 什么是线程池，为什么要用线程池

什么是线程池？为什么要用线程池？  

1、	降低资源的消耗。降低线程创建和销毁的资源消耗；
2、	提高响应速度：线程的创建时间为T1，执行时间T2,销毁时间T3，免去T1和T3的时间
3、	提高线程的可管理性。

### 实现一个我们自己的线程池

线程池满足条件：
1、线程必须在池子已经创建好了，并且可以保持住，要有容器保存多个线程；
2、线程还要能够接受外部的任务，运行这个任务。容器保持这个来不及运行的任务。


实现自己的线程池类

```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

/**
 * 类说明：自己线程池的实现
 */
public class MyThreadPool2 {

    // 线程池中默认线程的个数为5
    private static int WORK_NUM = 5;
    // 队列默认任务个数为100
    private static int TASK_COUNT = 100;

    // 工作线程组
    private WorkThread[] workThreads;

    // 任务队列，阻塞队列作为一个缓冲
    private final BlockingQueue<Runnable> taskQueue;
    // 用户在构造这个池，希望的启动的线程数
    private final int worker_num;

    // 创建具有默认线程个数的线程池
    public MyThreadPool2() {
        this(WORK_NUM, TASK_COUNT);
    }

    /**
     * 创建线程池,worker_num为线程池中工作线程的个数
     *
     * @param worker_num
     * @param taskCount
     */
    public MyThreadPool2(int worker_num, int taskCount) {
        if (worker_num <= 0) worker_num = WORK_NUM;
        if (taskCount <= 0) taskCount = TASK_COUNT;
        this.worker_num = worker_num;
        taskQueue = new ArrayBlockingQueue<>(taskCount);
        workThreads = new WorkThread[worker_num];
        for (int i = 0; i < worker_num; i++) {
            workThreads[i] = new WorkThread();
            workThreads[i].start();
        }
        Runtime.getRuntime().availableProcessors();
    }


    /**
     * 执行任务,其实只是把任务加入任务队列，什么时候执行有线程池管理器决定
     *
     * @param task
     */
    public void execute(Runnable task) {
        try {
            taskQueue.put(task);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }


    /**
     * 销毁线程池,该方法保证在所有任务都完成的情况下才销毁所有线程，否则等待任务完成才销毁
     */
    public void destroy() {
        // 工作线程停止工作，且置为null
        System.out.println("ready close pool.....");
        for (int i = 0; i < worker_num; i++) {
            workThreads[i].stopWorker();
            // help gc
            workThreads[i] = null;
        }
        taskQueue.clear();// 清空任务队列
    }

    /**
     * 覆盖toString方法，返回线程池信息：工作线程个数和已完成任务个数
     */
    @Override
    public String toString() {
        return "WorkThread number:" + worker_num
                + "  wait task number:" + taskQueue.size();
    }

    /**
     * 内部类，工作线程
     */
    private class WorkThread extends Thread {

        /**
         * 线程启动任务
         */
        @Override
        public void run() {
            Runnable r = null;
            try {
                // 判断当前线程有没有被终止，没有被终止执行业务
                while (!isInterrupted()) {
                    r = taskQueue.take();
                    if (r != null) {
                        // 打印出当前线程的ID
                        System.out.println(getId() + " ready exec :" + r);
                        // 执行线程
                        r.run();
                    }
                    // help gc;
                    r = null;
                }
            } catch (Exception e) {
                // TODO: handle exception
            }
        }

        /**
         * 终止当前任务
         */
        public void stopWorker() {
            interrupt();
        }
    }
}
```

使用测试类

```java
import java.util.Random;

/**
 * 类说明：
 */
public class TestMyThreadPool {
    public static void main(String[] args) throws InterruptedException {
        /**
         * 创建3个线程的线程池
         * 创建5个任务线程，
         * 线程池中最大执行任务的线程数为3，当再线程任务进入队列时，该线程不再执行，而是等待池子中其他线程执行完成后，即正在执行的线程小于3时，才执行该线程有空余执行的线程
         */
        MyThreadPool2 t = new MyThreadPool2(3, 0);
        t.execute(new MyTask("testA"));
        t.execute(new MyTask("testB"));
        t.execute(new MyTask("testC"));
        t.execute(new MyTask("testD"));
        t.execute(new MyTask("testE"));
        System.out.println(t);
        Thread.sleep(10000);
        // 所有线程都执行完成才destory
        t.destroy();
        System.out.println(t);
    }

    // 任务类
    static class MyTask implements Runnable {

        private String name;
        private Random r = new Random();

        public MyTask(String name) {
            this.name = name;
        }

        public String getName() {
            return name;
        }

        @Override
        public void run() {// 执行任务
            try {
                Thread.sleep(r.nextInt(1000) + 2000);
            } catch (InterruptedException e) {
                System.out.println(Thread.currentThread().getId() + " sleep InterruptedException:"
                        + Thread.currentThread().isInterrupted());
            }
            System.out.println("任务 " + name + " 完成");
        }
    }
}
```

测试结果

```
WorkThread number:3  wait task number:5
11 ready exec :com.xiangxue.ch6.mypool.TestMyThreadPool$MyTask@67d1f235
13 ready exec :com.xiangxue.ch6.mypool.TestMyThreadPool$MyTask@36b4fb79
12 ready exec :com.xiangxue.ch6.mypool.TestMyThreadPool$MyTask@42691bb0
任务 testC 完成
12 ready exec :com.xiangxue.ch6.mypool.TestMyThreadPool$MyTask@4caefd8d
任务 testB 完成
13 ready exec :com.xiangxue.ch6.mypool.TestMyThreadPool$MyTask@387313df
任务 testA 完成
任务 testE 完成
任务 testD 完成
ready close pool.....
WorkThread number:3  wait task number:0
```



