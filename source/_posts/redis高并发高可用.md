---
title: redis高并发高可用
date: 2019-11-18 21:26:47
update: 2019-11-18 21:26:47
categories: Redis
tags: [redis]
---

### 分布式锁

* 分布式锁是什么

* * 分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁实现

  * 如果不同的系统或同一个系统的不同主机之间共享了某个资源时，往往通过互斥来防止彼此干扰。

* 分布锁设计目的

​         可以保证在分布式部署的应用集群中，同一个方法在同一操作只能被一台机器上的一个线程执行。

* 设计要求
  * 这把锁要是一把可重入锁（避免死锁）
  * 这把锁有高可用的获取锁和释放锁功能
  * 这把锁获取锁和释放锁的性能要好… 

* 分布锁实现方案分析    
  * 获取锁的时候，使用 setnx(SETNX key val:当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1;
  * 若 key 存在，则什么都不做，返回 【0】加锁，锁的 value 值为当前占有锁服务器内网IP编号拼接任务标识
  * 在释放锁的时候进行判断。并使用 expire 命令为锁添 加一个超时时间，超过该时间则自动释放锁。 
  * 返回1则成功获取锁。还设置一个获取的超时时间， 若超过这个时间则放弃获取锁。setex（key,value,expire）过期以秒为单位
  * 释放锁的时候，判断是不是该锁（即Value为当前服务器内网IP编号拼接任务标识），若是该锁，则执行 delete 进行锁释放

### TCP三次握⼿

![redis高并发高可用-a](https://volc1612.gitee.io/blog/images/redis高并发高可用/redis高并发高可用-a.jpg)


首先Client端发送连接请求报文，Server段接受连接后回复ACK（响应）报文，并为这次连接分配资源。Client端接收到ACK（响应）报文后也向Server段发生ACK（响应）报文，并分配资源，这样TCP连接就建立了。

#### 为什么要三次握⼿，不能像http或者UDP⼀样直接传输

容易出现报文错乱。
主要是为了防⽌已失效的连接请求报⽂段突然⼜传到了B,因⽽报⽂错乱问题。假定A发出的第⼀个连
接请求报⽂段并没有丢失，⽽是在某些⽹络节点⻓时间滞留了，⼀直延迟到连接释放 以后的某个
时间才到达B，本来这是⼀个早已失效的报⽂段。但B收到此失效的连接请求报⽂段后，就误认为
是A⼜发出⼀次新的连接请求，于是就向A发出确认报⽂段，同意建⽴连接。假定不采⽤三次握
⼿，那么只要B发出确认，新的连接就建⽴了，这样⼀直等待A发来数据，B的许多资源就这样⽩⽩
浪费了。

#### 查询当前机器的连接数

```sh
[root@localhost xdclass-mobile-redis]# netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
ESTABLISHED 17
```

### TCP四次挥手

四次挥手用来断开连接

![redis高并发高可用-b](https://volc1612.gitee.io/blog/images/redis高并发高可用/redis高并发高可用-b.jpg)

* 面试题：你知道TCP四次挥手是什么吗？为什么要进行四次挥手

  * 确保数据能够完整传输

  * * 当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。

    * 但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET,它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接
    * 所以这里的ACK报文和FIN报文多数情况下都是分开发送的。

  * 模拟流程


        A:“喂，我不说了 (FIN)。”A->FIN_WAIT1
        
        B:“我知道了(ACK)。等下，上一句还没说完。Balabala…..（传输数据）”B->CLOSE_WAIT | A->FIN_WAIT2
        
        B:”好了，说完了，我也不说了（FIN）。”B->LAST_ACK
        
        A:”我知道了（ACK）。”A->TIME_WAIT | B->CLOSED
        
        A等待2MSL,保证B收到了消息,否则重说一次”我知道了”,A->CLOSED


* 图解分析TCP四次挥手协议

  * TCP前面10种状态切换

    

* TCP第11种状态CLOSING 状态概念

  * 这种状态在实际情况中应该很少见，属于一种比较罕见的例外状态。正常情况下，当一方发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING 状态表示一方发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？那就是当双方几乎在同时close()一个SOCKET的话，就出现了双方同时发送FIN报文的情况，这是就会出现CLOSING 状态，表示双方都正在关闭SOCKET连接。

* netstat -anp|grep 8080


**总结**
tcp共有11中状态
